// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for BookingStatus.
const (
	N1 BookingStatus = 1
	N2 BookingStatus = 2
	N3 BookingStatus = 3
)

// Defines values for ClusterInCloudProvider.
const (
	ClusterInCloudProviderAws     ClusterInCloudProvider = "aws"
	ClusterInCloudProviderAzure   ClusterInCloudProvider = "azure"
	ClusterInCloudProviderGcp     ClusterInCloudProvider = "gcp"
	ClusterInCloudProviderPrivate ClusterInCloudProvider = "private"
)

// Defines values for ClusterInCloudRegion.
const (
	ClusterInCloudRegionApNortheast1       ClusterInCloudRegion = "ap-northeast-1"
	ClusterInCloudRegionApSoutheast1       ClusterInCloudRegion = "ap-southeast-1"
	ClusterInCloudRegionApSoutheast2       ClusterInCloudRegion = "ap-southeast-2"
	ClusterInCloudRegionEastus             ClusterInCloudRegion = "eastus"
	ClusterInCloudRegionEuCentral          ClusterInCloudRegion = "eu-central"
	ClusterInCloudRegionEuCentral1         ClusterInCloudRegion = "eu-central-1"
	ClusterInCloudRegionEuWest2            ClusterInCloudRegion = "eu-west-2"
	ClusterInCloudRegionEuropeWest3        ClusterInCloudRegion = "europe-west3"
	ClusterInCloudRegionGermanywestcentral ClusterInCloudRegion = "germanywestcentral"
	ClusterInCloudRegionPrivate            ClusterInCloudRegion = "private"
	ClusterInCloudRegionSoutheastasia      ClusterInCloudRegion = "southeastasia"
	ClusterInCloudRegionUksouth            ClusterInCloudRegion = "uksouth"
	ClusterInCloudRegionUsEast1            ClusterInCloudRegion = "us-east-1"
	ClusterInCloudRegionUsEast4            ClusterInCloudRegion = "us-east4"
	ClusterInCloudRegionUsWest1            ClusterInCloudRegion = "us-west-1"
	ClusterInCloudRegionUsWest2            ClusterInCloudRegion = "us-west-2"
)

// Defines values for ClusterOutCloudProvider.
const (
	ClusterOutCloudProviderAws     ClusterOutCloudProvider = "aws"
	ClusterOutCloudProviderAzure   ClusterOutCloudProvider = "azure"
	ClusterOutCloudProviderGcp     ClusterOutCloudProvider = "gcp"
	ClusterOutCloudProviderPrivate ClusterOutCloudProvider = "private"
)

// Defines values for ClusterOutCloudRegion.
const (
	ClusterOutCloudRegionApNortheast1       ClusterOutCloudRegion = "ap-northeast-1"
	ClusterOutCloudRegionApSoutheast1       ClusterOutCloudRegion = "ap-southeast-1"
	ClusterOutCloudRegionApSoutheast2       ClusterOutCloudRegion = "ap-southeast-2"
	ClusterOutCloudRegionEastus             ClusterOutCloudRegion = "eastus"
	ClusterOutCloudRegionEuCentral          ClusterOutCloudRegion = "eu-central"
	ClusterOutCloudRegionEuCentral1         ClusterOutCloudRegion = "eu-central-1"
	ClusterOutCloudRegionEuWest2            ClusterOutCloudRegion = "eu-west-2"
	ClusterOutCloudRegionEuropeWest3        ClusterOutCloudRegion = "europe-west3"
	ClusterOutCloudRegionGermanywestcentral ClusterOutCloudRegion = "germanywestcentral"
	ClusterOutCloudRegionPrivate            ClusterOutCloudRegion = "private"
	ClusterOutCloudRegionSoutheastasia      ClusterOutCloudRegion = "southeastasia"
	ClusterOutCloudRegionUksouth            ClusterOutCloudRegion = "uksouth"
	ClusterOutCloudRegionUsEast1            ClusterOutCloudRegion = "us-east-1"
	ClusterOutCloudRegionUsEast4            ClusterOutCloudRegion = "us-east4"
	ClusterOutCloudRegionUsWest1            ClusterOutCloudRegion = "us-west-1"
	ClusterOutCloudRegionUsWest2            ClusterOutCloudRegion = "us-west-2"
)

// Defines values for ClusterState.
const (
	ClusterStateBackupRunning     ClusterState = "BackupRunning"
	ClusterStateCreating          ClusterState = "Creating"
	ClusterStateFailedToBackup    ClusterState = "FailedToBackup"
	ClusterStateFailedToCreate    ClusterState = "FailedToCreate"
	ClusterStateFailedToRestart   ClusterState = "FailedToRestart"
	ClusterStateFailedToRestore   ClusterState = "FailedToRestore"
	ClusterStateFailedToResume    ClusterState = "FailedToResume"
	ClusterStateFailedToScale     ClusterState = "FailedToScale"
	ClusterStateFailedToSuspend   ClusterState = "FailedToSuspend"
	ClusterStateFailedToSync      ClusterState = "FailedToSync"
	ClusterStateFailedToUpdate    ClusterState = "FailedToUpdate"
	ClusterStateFailedToUpgrade   ClusterState = "FailedToUpgrade"
	ClusterStateHealthy           ClusterState = "Healthy"
	ClusterStateManualMaintenance ClusterState = "ManualMaintenance"
	ClusterStateNotFound          ClusterState = "NotFound"
	ClusterStateNotReady          ClusterState = "NotReady"
	ClusterStateRecoveryMode      ClusterState = "RecoveryMode"
	ClusterStateRestarting        ClusterState = "Restarting"
	ClusterStateRestoring         ClusterState = "Restoring"
	ClusterStateResuming          ClusterState = "Resuming"
	ClusterStateScaling           ClusterState = "Scaling"
	ClusterStateSuspended         ClusterState = "Suspended"
	ClusterStateSuspending        ClusterState = "Suspending"
	ClusterStateUnknown           ClusterState = "Unknown"
	ClusterStateUpdating          ClusterState = "Updating"
	ClusterStateUpgrading         ClusterState = "Upgrading"
)

// Defines values for Currency.
const (
	Eur Currency = "eur"
	Usd Currency = "usd"
)

// Defines values for QdrantClusterStatus.
const (
	QdrantClusterStatusRunning   QdrantClusterStatus = "running"
	QdrantClusterStatusSuspended QdrantClusterStatus = "suspended"
)

// Defines values for ReplicationStatus.
const (
	ReplicationStatusDown            ReplicationStatus = "down"
	ReplicationStatusHealthy         ReplicationStatus = "healthy"
	ReplicationStatusUnderReplicated ReplicationStatus = "under_replicated"
	ReplicationStatusUnknown         ReplicationStatus = "unknown"
)

// Defines values for ResourceType.
const (
	ComplimentaryDisk ResourceType = "complimentary_disk"
	Cpu               ResourceType = "cpu"
	Disk              ResourceType = "disk"
	Ram               ResourceType = "ram"
	Snapshot          ResourceType = "snapshot"
)

// Defines values for ScheduleState.
const (
	ScheduleStateActive       ScheduleState = "Active"
	ScheduleStateFailedToSync ScheduleState = "FailedToSync"
	ScheduleStateNotFound     ScheduleState = "NotFound"
	ScheduleStateUnknown      ScheduleState = "Unknown"
)

// Defines values for TolerationEffect.
const (
	NoExecute        TolerationEffect = "NoExecute"
	NoSchedule       TolerationEffect = "NoSchedule"
	PreferNoSchedule TolerationEffect = "PreferNoSchedule"
)

// Defines values for TolerationOperator.
const (
	Equal  TolerationOperator = "Equal"
	Exists TolerationOperator = "Exists"
)

// AWSEncryptionConfig defines model for AWSEncryptionConfig.
type AWSEncryptionConfig struct {
	EncryptionKeyId *string `json:"encryption_key_id"`
	Managed         *bool   `json:"managed,omitempty"`
}

// ApiKeyIn defines model for ApiKeyIn.
type ApiKeyIn struct {
	ClusterIdList *[]string `json:"cluster_id_list"`
}

// BookingStatus PLANNED - 1: The booking is planned, but not yet active
// ACTIVE - 2: The booking is active
// DEACTIVATED - 3: The booking is deactivated
type BookingStatus int

// ClusterConfigurationIn defines model for ClusterConfigurationIn.
type ClusterConfigurationIn struct {
	AllowedIpSourceRanges *[]string               `json:"allowed_ip_source_ranges"`
	ClusterAnnotations    *map[string]interface{} `json:"cluster_annotations"`
	NodeConfiguration     NodeConfiguration       `json:"node_configuration"`
	NodeSelector          *map[string]string      `json:"node_selector"`
	NumNodes              int                     `json:"num_nodes"`
	NumNodesMax           int                     `json:"num_nodes_max"`
	QdrantConfiguration   *map[string]interface{} `json:"qdrant_configuration"`
	Tolerations           *[]Toleration           `json:"tolerations"`
}

// ClusterConfigurationOut defines model for ClusterConfigurationOut.
type ClusterConfigurationOut struct {
	AllowedIpSourceRanges *[]string               `json:"allowed_ip_source_ranges"`
	ClusterAnnotations    *map[string]interface{} `json:"cluster_annotations"`
	ClusterId             string                  `json:"cluster_id"`
	CreatedAt             time.Time               `json:"created_at"`
	Id                    string                  `json:"id"`
	NodeConfiguration     NodeConfiguration       `json:"node_configuration"`
	NodeSelector          *map[string]string      `json:"node_selector"`
	NumNodes              int                     `json:"num_nodes"`
	NumNodesMax           int                     `json:"num_nodes_max"`
	QdrantConfiguration   *map[string]interface{} `json:"qdrant_configuration"`
	Tolerations           *[]Toleration           `json:"tolerations"`
}

// ClusterIn defines model for ClusterIn.
type ClusterIn struct {
	AccountId        *string                `json:"account_id"`
	CloudProvider    ClusterInCloudProvider `json:"cloud_provider"`
	CloudRegion      ClusterInCloudRegion   `json:"cloud_region"`
	CloudRegionAz    *string                `json:"cloud_region_az"`
	CloudRegionSetup *string                `json:"cloud_region_setup"`
	Configuration    ClusterConfigurationIn `json:"configuration"`
	EncryptionConfig *EncryptionConfigIn    `json:"encryption_config,omitempty"`
	Name             string                 `json:"name"`
	OwnerId          *string                `json:"owner_id"`
	PrivateRegionId  *string                `json:"private_region_id"`
	Schedule         *ScheduleIn            `json:"schedule,omitempty"`
	Version          *string                `json:"version"`
}

// ClusterInCloudProvider defines model for ClusterIn.CloudProvider.
type ClusterInCloudProvider string

// ClusterInCloudRegion defines model for ClusterIn.CloudRegion.
type ClusterInCloudRegion string

// ClusterOut defines model for ClusterOut.
type ClusterOut struct {
	AccountId              *string                  `json:"account_id"`
	CloudProvider          ClusterOutCloudProvider  `json:"cloud_provider"`
	CloudRegion            ClusterOutCloudRegion    `json:"cloud_region"`
	CloudRegionAz          *string                  `json:"cloud_region_az"`
	CloudRegionSetup       *string                  `json:"cloud_region_setup"`
	Configuration          *ClusterConfigurationOut `json:"configuration,omitempty"`
	CreatedAt              time.Time                `json:"created_at"`
	CurrentConfigurationId string                   `json:"current_configuration_id"`
	EncryptionKeyId        *string                  `json:"encryption_key_id"`
	Id                     string                   `json:"id"`
	MarkedForDeletionAt    *time.Time               `json:"marked_for_deletion_at"`
	Name                   string                   `json:"name"`
	OwnerId                *string                  `json:"owner_id"`
	PrivateRegionId        *string                  `json:"private_region_id"`
	Resources              *ClusterResourcesSummary `json:"resources,omitempty"`
	State                  *QdrantClusterState      `json:"state,omitempty"`
	TotalExtraDisk         *int                     `json:"total_extra_disk,omitempty"`
	Url                    string                   `json:"url"`
	Version                *string                  `json:"version"`
}

// ClusterOutCloudProvider defines model for ClusterOut.CloudProvider.
type ClusterOutCloudProvider string

// ClusterOutCloudRegion defines model for ClusterOut.CloudRegion.
type ClusterOutCloudRegion string

// ClusterResources defines model for ClusterResources.
type ClusterResources struct {
	Base          *float32 `json:"base,omitempty"`
	Complimentary *float32 `json:"complimentary,omitempty"`
	Extra         *float32 `json:"extra,omitempty"`
}

// ClusterResourcesSummary defines model for ClusterResourcesSummary.
type ClusterResourcesSummary struct {
	Cpu  *ClusterResources `json:"cpu,omitempty"`
	Disk *ClusterResources `json:"disk,omitempty"`
	Ram  *ClusterResources `json:"ram,omitempty"`
}

// ClusterState Cluster states replicated from Qdrant operator
type ClusterState string

// CreateApiKeyOut defines model for CreateApiKeyOut.
type CreateApiKeyOut struct {
	AccountId     *string   `json:"account_id"`
	ClusterIdList *[]string `json:"cluster_id_list"`
	CreatedAt     time.Time `json:"created_at"`
	Id            string    `json:"id"`
	Prefix        string    `json:"prefix"`
	Token         string    `json:"token"`
	UserId        *string   `json:"user_id"`
}

// Currency defines model for Currency.
type Currency string

// EncryptionConfigIn defines model for EncryptionConfigIn.
type EncryptionConfigIn struct {
	AwsEncryptionConfig *AWSEncryptionConfig `json:"aws_encryption_config,omitempty"`
}

// GetApiKeyOut defines model for GetApiKeyOut.
type GetApiKeyOut struct {
	AccountId     *string   `json:"account_id"`
	ClusterIdList *[]string `json:"cluster_id_list"`
	CreatedAt     time.Time `json:"created_at"`
	Id            string    `json:"id"`
	Prefix        string    `json:"prefix"`
	UserId        *string   `json:"user_id"`
}

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// NodeConfiguration defines model for NodeConfiguration.
type NodeConfiguration struct {
	Package                *PackageOut              `json:"package,omitempty"`
	PackageId              string                   `json:"package_id"`
	ResourceConfigurations *[]ResourceConfiguration `json:"resource_configurations"`
}

// PackageOut defines model for PackageOut.
type PackageOut struct {
	Currency              Currency                `json:"currency"`
	Id                    *string                 `json:"id"`
	Name                  string                  `json:"name"`
	RegionalMappingId     *string                 `json:"regional_mapping_id"`
	ResourceConfiguration []ResourceConfiguration `json:"resource_configuration"`

	// Status PLANNED - 1: The booking is planned, but not yet active
	// ACTIVE - 2: The booking is active
	// DEACTIVATED - 3: The booking is deactivated
	Status               BookingStatus `json:"status"`
	UnitIntPricePerDay   *int          `json:"unit_int_price_per_day"`
	UnitIntPricePerHour  *int          `json:"unit_int_price_per_hour"`
	UnitIntPricePerMonth *int          `json:"unit_int_price_per_month"`
	UnitIntPricePerYear  *int          `json:"unit_int_price_per_year"`
}

// PydanticClusterConfigurationPatchIn defines model for PydanticClusterConfigurationPatchIn.
type PydanticClusterConfigurationPatchIn struct {
	AllowedIpSourceRanges *[]string          `json:"allowed_ip_source_ranges"`
	NodeSelector          *map[string]string `json:"node_selector"`
	NumNodes              *int               `json:"num_nodes"`
	Tolerations           *[]Toleration      `json:"tolerations"`
}

// PydanticClusterPatchIn defines model for PydanticClusterPatchIn.
type PydanticClusterPatchIn struct {
	Configuration          *PydanticClusterConfigurationPatchIn `json:"configuration,omitempty"`
	ResourceConfigurations *[]ResourceConfiguration             `json:"resource_configurations"`
	Rolling                *bool                                `json:"rolling"`
	Status                 *PydanticClusterStatusPatchIn        `json:"status,omitempty"`
	Version                *string                              `json:"version"`
}

// PydanticClusterStatusPatchIn defines model for PydanticClusterStatusPatchIn.
type PydanticClusterStatusPatchIn struct {
	RestartedAt string `json:"restarted_at"`
}

// QdrantClusterNodeState defines model for QdrantClusterNodeState.
type QdrantClusterNodeState struct {
	Endpoint  *string            `json:"endpoint,omitempty"`
	Name      string             `json:"name"`
	StartedAt *time.Time         `json:"started_at"`
	State     *map[string]string `json:"state,omitempty"`
	Version   *string            `json:"version,omitempty"`
}

// QdrantClusterState defines model for QdrantClusterState.
type QdrantClusterState struct {
	AvailableReplicas *int `json:"available_replicas"`

	// Current Whether the cluster is running.
	Current  *QdrantClusterStatus                      `json:"current,omitempty"`
	Endpoint *string                                   `json:"endpoint"`
	Id       string                                    `json:"id"`
	Nodes    *map[string]*QdrantClusterStateNodesValue `json:"nodes"`

	// Phase Cluster states replicated from Qdrant operator
	Phase             *ClusterState     `json:"phase,omitempty"`
	Reason            *string           `json:"reason"`
	Replicas          int               `json:"replicas"`
	ReplicationStatus ReplicationStatus `json:"replicationStatus"`
	RestartedAt       *time.Time        `json:"restarted_at"`
	Version           *string           `json:"version"`
}

// QdrantClusterStateNodesValue defines model for QdrantClusterState_nodes_value.
type QdrantClusterStateNodesValue struct {
	union json.RawMessage
}

// QdrantClusterStatus defines model for QdrantClusterStatus.
type QdrantClusterStatus string

// ReplicationStatus defines model for ReplicationStatus.
type ReplicationStatus string

// ResourceConfiguration defines model for ResourceConfiguration.
type ResourceConfiguration struct {
	Amount           int                `json:"amount"`
	ResourceOption   *ResourceOptionOut `json:"resource_option,omitempty"`
	ResourceOptionId string             `json:"resource_option_id"`
}

// ResourceOptionOut defines model for ResourceOptionOut.
type ResourceOptionOut struct {
	Currency     Currency     `json:"currency"`
	Id           string       `json:"id"`
	Name         *string      `json:"name"`
	ResourceType ResourceType `json:"resource_type"`
	ResourceUnit string       `json:"resource_unit"`

	// Status PLANNED - 1: The booking is planned, but not yet active
	// ACTIVE - 2: The booking is active
	// DEACTIVATED - 3: The booking is deactivated
	Status               BookingStatus `json:"status"`
	UnitIntPricePerDay   *int          `json:"unit_int_price_per_day"`
	UnitIntPricePerHour  *int          `json:"unit_int_price_per_hour"`
	UnitIntPricePerMonth *int          `json:"unit_int_price_per_month"`
	UnitIntPricePerYear  *int          `json:"unit_int_price_per_year"`
}

// ResourceType defines model for ResourceType.
type ResourceType string

// ScheduleIn defines model for ScheduleIn.
type ScheduleIn struct {
	AccountId           *string        `json:"account_id"`
	CreatorUserId       *string        `json:"creator_user_id"`
	Cron                string         `json:"cron"`
	MarkedForDeletionAt *time.Time     `json:"marked_for_deletion_at"`
	PrivateRegionId     *string        `json:"private_region_id"`
	Retention           int            `json:"retention"`
	Status              *ScheduleState `json:"status,omitempty"`
}

// ScheduleState defines model for ScheduleState.
type ScheduleState string

// Toleration defines model for Toleration.
type Toleration struct {
	Effect            *TolerationEffect  `json:"effect"`
	Key               *string            `json:"key"`
	Operator          TolerationOperator `json:"operator"`
	TolerationSeconds *int               `json:"toleration_seconds"`
	Value             *string            `json:"value"`
}

// TolerationEffect defines model for Toleration.Effect.
type TolerationEffect string

// TolerationOperator defines model for Toleration.Operator.
type TolerationOperator string

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []ValidationErrorLocInner `json:"loc"`
	Msg  string                    `json:"msg"`
	Type string                    `json:"type"`
}

// ValidationErrorLocInner defines model for ValidationError_loc_inner.
type ValidationErrorLocInner struct {
	union json.RawMessage
}

// ValidationErrorLocInner0 defines model for .
type ValidationErrorLocInner0 = string

// ValidationErrorLocInner1 defines model for .
type ValidationErrorLocInner1 = int

// ListClustersParams defines parameters for ListClusters.
type ListClustersParams struct {
	PrivateRegionId *string `form:"private_region_id,omitempty" json:"private_region_id,omitempty"`
}

// DeleteClusterParams defines parameters for DeleteCluster.
type DeleteClusterParams struct {
	DeleteBackups *bool `form:"delete_backups,omitempty" json:"delete_backups,omitempty"`
}

// GetPackagesParams defines parameters for GetPackages.
type GetPackagesParams struct {
	Provider *string `form:"provider,omitempty" json:"provider,omitempty"`
	Region   *string `form:"region,omitempty" json:"region,omitempty"`
}

// CreateApiKeyJSONRequestBody defines body for CreateApiKey for application/json ContentType.
type CreateApiKeyJSONRequestBody = ApiKeyIn

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = ClusterIn

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = PydanticClusterPatchIn

// AsQdrantClusterNodeState returns the union data inside the QdrantClusterStateNodesValue as a QdrantClusterNodeState
func (t QdrantClusterStateNodesValue) AsQdrantClusterNodeState() (QdrantClusterNodeState, error) {
	var body QdrantClusterNodeState
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromQdrantClusterNodeState overwrites any union data inside the QdrantClusterStateNodesValue as the provided QdrantClusterNodeState
func (t *QdrantClusterStateNodesValue) FromQdrantClusterNodeState(v QdrantClusterNodeState) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeQdrantClusterNodeState performs a merge with any union data inside the QdrantClusterStateNodesValue, using the provided QdrantClusterNodeState
func (t *QdrantClusterStateNodesValue) MergeQdrantClusterNodeState(v QdrantClusterNodeState) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t QdrantClusterStateNodesValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *QdrantClusterStateNodesValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsValidationErrorLocInner0 returns the union data inside the ValidationErrorLocInner as a ValidationErrorLocInner0
func (t ValidationErrorLocInner) AsValidationErrorLocInner0() (ValidationErrorLocInner0, error) {
	var body ValidationErrorLocInner0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLocInner0 overwrites any union data inside the ValidationErrorLocInner as the provided ValidationErrorLocInner0
func (t *ValidationErrorLocInner) FromValidationErrorLocInner0(v ValidationErrorLocInner0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLocInner0 performs a merge with any union data inside the ValidationErrorLocInner, using the provided ValidationErrorLocInner0
func (t *ValidationErrorLocInner) MergeValidationErrorLocInner0(v ValidationErrorLocInner0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLocInner1 returns the union data inside the ValidationErrorLocInner as a ValidationErrorLocInner1
func (t ValidationErrorLocInner) AsValidationErrorLocInner1() (ValidationErrorLocInner1, error) {
	var body ValidationErrorLocInner1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLocInner1 overwrites any union data inside the ValidationErrorLocInner as the provided ValidationErrorLocInner1
func (t *ValidationErrorLocInner) FromValidationErrorLocInner1(v ValidationErrorLocInner1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLocInner1 performs a merge with any union data inside the ValidationErrorLocInner, using the provided ValidationErrorLocInner1
func (t *ValidationErrorLocInner) MergeValidationErrorLocInner1(v ValidationErrorLocInner1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationErrorLocInner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationErrorLocInner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApiKeys request
	ListApiKeys(ctx context.Context, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKeyWithBody request with any body
	CreateApiKeyWithBody(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiKey(ctx context.Context, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKey request
	DeleteApiKey(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusters request
	ListClusters(ctx context.Context, accountId openapi_types.UUID, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, accountId openapi_types.UUID, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackages request
	GetPackages(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListApiKeys(ctx context.Context, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyWithBody(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKey(ctx context.Context, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKey(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeyRequest(c.Server, accountId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusters(ctx context.Context, accountId openapi_types.UUID, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, accountId openapi_types.UUID, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, accountId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, accountId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, accountId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, accountId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackages(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListApiKeysRequest generates requests for ListApiKeys
func NewListApiKeysRequest(server string, accountId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/auth/api-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyRequest calls the generic CreateApiKey builder with application/json body
func NewCreateApiKeyRequest(server string, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiKeyRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateApiKeyRequestWithBody generates requests for CreateApiKey with any type of body
func NewCreateApiKeyRequestWithBody(server string, accountId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/auth/api-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApiKeyRequest generates requests for DeleteApiKey
func NewDeleteApiKeyRequest(server string, accountId openapi_types.UUID, apiKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "api_key_id", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/auth/api-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, accountId openapi_types.UUID, params *ListClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PrivateRegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private_region_id", runtime.ParamLocationQuery, *params.PrivateRegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, accountId openapi_types.UUID, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, accountId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteBackups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_backups", runtime.ParamLocationQuery, *params.DeleteBackups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, accountId openapi_types.UUID, clusterId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, accountId, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPackagesRequest generates requests for GetPackages
func NewGetPackagesRequest(server string, params *GetPackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/booking/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Provider != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, *params.Provider); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Region != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, *params.Region); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListApiKeysWithResponse request
	ListApiKeysWithResponse(ctx context.Context, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error)

	// CreateApiKeyWithBodyWithResponse request with any body
	CreateApiKeyWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	CreateApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	// DeleteApiKeyWithResponse request
	DeleteApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyResponse, error)

	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, accountId openapi_types.UUID, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// GetPackagesWithResponse request
	GetPackagesWithResponse(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*GetPackagesResponse, error)
}

type ListApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]GetApiKeyOut
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateApiKeyOut
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClusterOut
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterOut
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterOut
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterOut
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageOut
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListApiKeysWithResponse request returning *ListApiKeysResponse
func (c *ClientWithResponses) ListApiKeysWithResponse(ctx context.Context, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error) {
	rsp, err := c.ListApiKeys(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysResponse(rsp)
}

// CreateApiKeyWithBodyWithResponse request with arbitrary body returning *CreateApiKeyResponse
func (c *ClientWithResponses) CreateApiKeyWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKeyWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKey(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

// DeleteApiKeyWithResponse request returning *DeleteApiKeyResponse
func (c *ClientWithResponses) DeleteApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyResponse, error) {
	rsp, err := c.DeleteApiKey(ctx, accountId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeyResponse(rsp)
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, accountId openapi_types.UUID, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, accountId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, accountId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, accountId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, accountId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// GetPackagesWithResponse request returning *GetPackagesResponse
func (c *ClientWithResponses) GetPackagesWithResponse(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*GetPackagesResponse, error) {
	rsp, err := c.GetPackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagesResponse(rsp)
}

// ParseListApiKeysResponse parses an HTTP response from a ListApiKeysWithResponse call
func ParseListApiKeysResponse(rsp *http.Response) (*ListApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []GetApiKeyOut
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateApiKeyResponse parses an HTTP response from a CreateApiKeyWithResponse call
func ParseCreateApiKeyResponse(rsp *http.Response) (*CreateApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateApiKeyOut
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeyResponse parses an HTTP response from a DeleteApiKeyWithResponse call
func ParseDeleteApiKeyResponse(rsp *http.Response) (*DeleteApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClusterOut
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterOut
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterOut
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterOut
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPackagesResponse parses an HTTP response from a GetPackagesWithResponse call
func ParseGetPackagesResponse(rsp *http.Response) (*GetPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageOut
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}
