// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Defines values for ClusterSchemaCloudProvider.
const (
	ClusterSchemaCloudProviderAws     ClusterSchemaCloudProvider = "aws"
	ClusterSchemaCloudProviderAzure   ClusterSchemaCloudProvider = "azure"
	ClusterSchemaCloudProviderGcp     ClusterSchemaCloudProvider = "gcp"
	ClusterSchemaCloudProviderPrivate ClusterSchemaCloudProvider = "private"
)

// Defines values for ClusterSchemaCloudRegion.
const (
	ClusterSchemaCloudRegionApNortheast1       ClusterSchemaCloudRegion = "ap-northeast-1"
	ClusterSchemaCloudRegionApSoutheast1       ClusterSchemaCloudRegion = "ap-southeast-1"
	ClusterSchemaCloudRegionApSoutheast2       ClusterSchemaCloudRegion = "ap-southeast-2"
	ClusterSchemaCloudRegionEastus             ClusterSchemaCloudRegion = "eastus"
	ClusterSchemaCloudRegionEuCentral          ClusterSchemaCloudRegion = "eu-central"
	ClusterSchemaCloudRegionEuCentral1         ClusterSchemaCloudRegion = "eu-central-1"
	ClusterSchemaCloudRegionEuWest2            ClusterSchemaCloudRegion = "eu-west-2"
	ClusterSchemaCloudRegionEuropeWest3        ClusterSchemaCloudRegion = "europe-west3"
	ClusterSchemaCloudRegionGermanywestcentral ClusterSchemaCloudRegion = "germanywestcentral"
	ClusterSchemaCloudRegionPrivate            ClusterSchemaCloudRegion = "private"
	ClusterSchemaCloudRegionSoutheastasia      ClusterSchemaCloudRegion = "southeastasia"
	ClusterSchemaCloudRegionUksouth            ClusterSchemaCloudRegion = "uksouth"
	ClusterSchemaCloudRegionUsEast1            ClusterSchemaCloudRegion = "us-east-1"
	ClusterSchemaCloudRegionUsEast4            ClusterSchemaCloudRegion = "us-east4"
	ClusterSchemaCloudRegionUsWest1            ClusterSchemaCloudRegion = "us-west-1"
	ClusterSchemaCloudRegionUsWest2            ClusterSchemaCloudRegion = "us-west-2"
)

// Defines values for ClusterState.
const (
	BackupRunning     ClusterState = "BackupRunning"
	Creating          ClusterState = "Creating"
	FailedToBackup    ClusterState = "FailedToBackup"
	FailedToCreate    ClusterState = "FailedToCreate"
	FailedToRestart   ClusterState = "FailedToRestart"
	FailedToRestore   ClusterState = "FailedToRestore"
	FailedToResume    ClusterState = "FailedToResume"
	FailedToScale     ClusterState = "FailedToScale"
	FailedToSuspend   ClusterState = "FailedToSuspend"
	FailedToSync      ClusterState = "FailedToSync"
	FailedToUpdate    ClusterState = "FailedToUpdate"
	FailedToUpgrade   ClusterState = "FailedToUpgrade"
	Healthy           ClusterState = "Healthy"
	ManualMaintenance ClusterState = "ManualMaintenance"
	NotFound          ClusterState = "NotFound"
	NotReady          ClusterState = "NotReady"
	RecoveryMode      ClusterState = "RecoveryMode"
	Restarting        ClusterState = "Restarting"
	Restoring         ClusterState = "Restoring"
	Resuming          ClusterState = "Resuming"
	Scaling           ClusterState = "Scaling"
	Suspended         ClusterState = "Suspended"
	Suspending        ClusterState = "Suspending"
	Unknown           ClusterState = "Unknown"
	Updating          ClusterState = "Updating"
	Upgrading         ClusterState = "Upgrading"
)

// Defines values for Currency.
const (
	Eur Currency = "eur"
	Usd Currency = "usd"
)

// Defines values for ResourceType.
const (
	ComplimentaryDisk ResourceType = "complimentary_disk"
	Cpu               ResourceType = "cpu"
	Disk              ResourceType = "disk"
	Ram               ResourceType = "ram"
	Snapshot          ResourceType = "snapshot"
)

// Defines values for ResourceUnit.
const (
	Gi ResourceUnit = "Gi"
	M  ResourceUnit = "m"
)

// Defines values for TolerationSchemaEffect.
const (
	NoExecute        TolerationSchemaEffect = "NoExecute"
	NoSchedule       TolerationSchemaEffect = "NoSchedule"
	PreferNoSchedule TolerationSchemaEffect = "PreferNoSchedule"
)

// Defines values for TolerationSchemaOperator.
const (
	Equal  TolerationSchemaOperator = "Equal"
	Exists TolerationSchemaOperator = "Exists"
)

// Defines values for GetPackagesParamsProvider.
const (
	GetPackagesParamsProviderAws     GetPackagesParamsProvider = "aws"
	GetPackagesParamsProviderAzure   GetPackagesParamsProvider = "azure"
	GetPackagesParamsProviderGcp     GetPackagesParamsProvider = "gcp"
	GetPackagesParamsProviderPrivate GetPackagesParamsProvider = "private"
)

// Defines values for GetPackagesParamsRegion.
const (
	GetPackagesParamsRegionApNortheast1       GetPackagesParamsRegion = "ap-northeast-1"
	GetPackagesParamsRegionApSoutheast1       GetPackagesParamsRegion = "ap-southeast-1"
	GetPackagesParamsRegionApSoutheast2       GetPackagesParamsRegion = "ap-southeast-2"
	GetPackagesParamsRegionEastus             GetPackagesParamsRegion = "eastus"
	GetPackagesParamsRegionEuCentral          GetPackagesParamsRegion = "eu-central"
	GetPackagesParamsRegionEuCentral1         GetPackagesParamsRegion = "eu-central-1"
	GetPackagesParamsRegionEuWest2            GetPackagesParamsRegion = "eu-west-2"
	GetPackagesParamsRegionEuropeWest3        GetPackagesParamsRegion = "europe-west3"
	GetPackagesParamsRegionGermanywestcentral GetPackagesParamsRegion = "germanywestcentral"
	GetPackagesParamsRegionPrivate            GetPackagesParamsRegion = "private"
	GetPackagesParamsRegionSoutheastasia      GetPackagesParamsRegion = "southeastasia"
	GetPackagesParamsRegionUksouth            GetPackagesParamsRegion = "uksouth"
	GetPackagesParamsRegionUsEast1            GetPackagesParamsRegion = "us-east-1"
	GetPackagesParamsRegionUsEast4            GetPackagesParamsRegion = "us-east4"
	GetPackagesParamsRegionUsWest1            GetPackagesParamsRegion = "us-west-1"
	GetPackagesParamsRegionUsWest2            GetPackagesParamsRegion = "us-west-2"
)

// ApiKeySchema defines model for ApiKeySchema.
type ApiKeySchema struct {
	// ClusterIds A list of cluster IDs Should contain at least a single ID. After creation, this field cannot be changed
	ClusterIds []openapi_types.UUID `json:"cluster_ids"`
	CreatedAt  *time.Time           `json:"created_at"`
	Id         *openapi_types.UUID  `json:"id"`
	Prefix     *string              `json:"prefix"`
	Token      *string              `json:"token"`
}

// ClusterConfigurationSchema defines model for ClusterConfigurationSchema.
type ClusterConfigurationSchema struct {
	AllowedIpSourceRanges *[]string           `json:"allowed_ip_source_ranges,omitempty"`
	ClusterAnnotations    *map[string]string  `json:"cluster_annotations,omitempty"`
	CreatedAt             *time.Time          `json:"created_at"`
	Id                    *openapi_types.UUID `json:"id"`

	// NodeConfiguration The node configuration for this cluster. This is a required field
	NodeConfiguration NodeConfigurationSchema `json:"node_configuration"`
	NodeSelector      *map[string]string      `json:"node_selector,omitempty"`

	// NumberOfNodes The number of nodes in a cluster. This is a required field
	NumberOfNodes       int                        `json:"number_of_nodes"`
	QdrantConfiguration *QdrantConfigurationSchema `json:"qdrant_configuration,omitempty"`
	Tolerations         *interface{}               `json:"tolerations"`
}

// ClusterResourceSchema defines model for ClusterResourceSchema.
type ClusterResourceSchema struct {
	// Base Base resources that are part of the standard allocation for the cluster.
	//             Those resources are coming from the package.
	//
	Base *int `json:"base,omitempty"`

	// Complimentary Complimentary resources provided to the cluster at no additional cost.
	//             This might include complimentary network bandwidth, credits, etc.
	//
	Complimentary *int `json:"complimentary,omitempty"`

	// Extra Extra resources allocated to the cluster. This could include additional storage,
	//             compute power, etc. Additional storage means that you have 32 GB of storage in the package,
	//             but you want to add 10 GB more.
	//
	Extra *int `json:"extra,omitempty"`
}

// ClusterResourcesSchema defines model for ClusterResourcesSchema.
type ClusterResourcesSchema struct {
	// Cpu CPU resources used by the cluster
	Cpu ClusterResourceSchema `json:"cpu"`

	// Disk Disk resources used by the cluster
	Disk ClusterResourceSchema `json:"disk"`

	// Ram RAM resources used by the cluster
	Ram ClusterResourceSchema `json:"ram"`
}

// ClusterSchema defines model for ClusterSchema.
type ClusterSchema struct {
	// AccountId Identifier of the account associated with the cluster (in Guid format).
	//             This is a read-only field and will be available after a cluster is created
	//
	AccountId openapi_types.UUID `json:"account_id"`

	// CloudProvider Cloud provider where the cluster is hosted.
	//                 This is a required field if the cluster does not belong to Hybrid Cloud Environment.
	//                 If cluster belongs to Hybrid Cloud Environment, then it is automatically filled with
	//                 value `private`.  After creation, this field cannot be changed.
	//
	CloudProvider *ClusterSchemaCloudProvider `json:"cloud_provider,omitempty"`

	// CloudRegion
	//                 Cloud region where the cluster is located.
	//                 This is a required field if the cluster does not belong to Hybrid Cloud Environment.
	//                 If cluster belongs to Hybrid Cloud Environment, then it is automatically filled
	//                 with value `private`. After creation, this field cannot be changed.
	//
	CloudRegion *ClusterSchemaCloudRegion `json:"cloud_region,omitempty"`

	// Configuration Current configuration details of the cluster
	Configuration       ClusterConfigurationSchema `json:"configuration"`
	CreatedAt           *time.Time                 `json:"created_at"`
	Id                  *openapi_types.UUID        `json:"id"`
	MarkedForDeletionAt *time.Time                 `json:"marked_for_deletion_at"`

	// Name Name of the cluster. This is a required field.
	//             Name can only contain letters, numbers, underscores and dashes
	//
	Name            string                  `json:"name"`
	PrivateRegionId *openapi_types.UUID     `json:"private_region_id"`
	Resources       *ClusterResourcesSchema `json:"resources,omitempty"`
	State           *ClusterStateSchema     `json:"state,omitempty"`
	Url             *string                 `json:"url"`
	Version         *string                 `json:"version"`
}

// ClusterSchemaCloudProvider Cloud provider where the cluster is hosted.
//
//	This is a required field if the cluster does not belong to Hybrid Cloud Environment.
//	If cluster belongs to Hybrid Cloud Environment, then it is automatically filled with
//	value `private`.  After creation, this field cannot be changed.
type ClusterSchemaCloudProvider string

// ClusterSchemaCloudRegion
//
//	Cloud region where the cluster is located.
//	This is a required field if the cluster does not belong to Hybrid Cloud Environment.
//	If cluster belongs to Hybrid Cloud Environment, then it is automatically filled
//	with value `private`. After creation, this field cannot be changed.
type ClusterSchemaCloudRegion string

// ClusterState Cluster states replicated from Qdrant operator
type ClusterState string

// ClusterStateSchema defines model for ClusterStateSchema.
type ClusterStateSchema struct {
	Endpoint *string `json:"endpoint"`

	// NodesUp Number of cluster nodes that are up and running
	NodesUp int `json:"nodes_up"`

	// Phase Current phase of the cluster
	Phase       *ClusterState `json:"phase,omitempty"`
	Reason      *string       `json:"reason"`
	RestartedAt *time.Time    `json:"restarted_at"`
	Version     *string       `json:"version"`
}

// Currency defines model for Currency.
type Currency string

// HTTPValidationError defines model for HTTPValidationError.
type HTTPValidationError struct {
	Detail *[]ValidationError `json:"detail,omitempty"`
}

// NodeConfigurationSchema defines model for NodeConfigurationSchema.
type NodeConfigurationSchema struct {
	// PackageId Identifier of the package associated with the node configuration (in Guid format)
	PackageId              openapi_types.UUID `json:"package_id"`
	ResourceConfigurations *interface{}       `json:"resource_configurations"`
}

// PackageSchema defines model for PackageSchema.
type PackageSchema struct {
	// Currency The currency of the package
	Currency Currency `json:"currency"`

	// Id The unique identifier of the package
	Id string `json:"id"`

	// Name A human-readable identifier for the package
	Name string `json:"name"`

	// ResourceConfiguration The resource configuration of the package
	ResourceConfiguration []ResourceConfigurationSchema `json:"resource_configuration"`
	UnitIntPricePerHour   *int                          `json:"unit_int_price_per_hour"`
}

// QdrantConfigApiKey defines model for QdrantConfigApiKey.
type QdrantConfigApiKey struct {
	SecretKeyRef SecretKeyRef `json:"secretKeyRef"`
}

// QdrantConfigurationSchema defines model for QdrantConfigurationSchema.
type QdrantConfigurationSchema struct {
	LogLevel *string                           `json:"log_level"`
	Service  *QdrantConfigurationServiceConfig `json:"service,omitempty"`
}

// QdrantConfigurationServiceConfig defines model for QdrantConfigurationServiceConfig.
type QdrantConfigurationServiceConfig struct {
	ApiKey         *QdrantConfigApiKey `json:"api_key,omitempty"`
	JwtRbac        *bool               `json:"jwt_rbac"`
	ReadOnlyApiKey *QdrantConfigApiKey `json:"read_only_api_key,omitempty"`
}

// ResourceConfigurationSchema defines model for ResourceConfigurationSchema.
type ResourceConfigurationSchema struct {
	// Amount The amount in the specified unit
	Amount int `json:"amount"`

	// ResourceType The type of the resource (e.g., CPU, RAM)
	ResourceType ResourceType `json:"resource_type"`

	// ResourceUnit The unit of the resource, specifying what kind of unit the resource is measured in (e.g., m, Gib)
	ResourceUnit ResourceUnit `json:"resource_unit"`
}

// ResourceType defines model for ResourceType.
type ResourceType string

// ResourceUnit defines model for ResourceUnit.
type ResourceUnit string

// SecretKeyRef defines model for SecretKeyRef.
type SecretKeyRef struct {
	Key  string `json:"key"`
	Name string `json:"name"`
}

// TolerationSchema defines model for TolerationSchema.
type TolerationSchema struct {
	Effect            *TolerationSchemaEffect  `json:"effect"`
	Key               *string                  `json:"key"`
	Operator          TolerationSchemaOperator `json:"operator"`
	TolerationSeconds *int                     `json:"toleration_seconds"`
	Value             *string                  `json:"value"`
}

// TolerationSchemaEffect defines model for TolerationSchema.Effect.
type TolerationSchemaEffect string

// TolerationSchemaOperator defines model for TolerationSchema.Operator.
type TolerationSchemaOperator string

// ValidationError defines model for ValidationError.
type ValidationError struct {
	Loc  []ValidationErrorLocInner `json:"loc"`
	Msg  string                    `json:"msg"`
	Type string                    `json:"type"`
}

// ValidationErrorLocInner defines model for ValidationError_loc_inner.
type ValidationErrorLocInner struct {
	union json.RawMessage
}

// ValidationErrorLocInner0 defines model for .
type ValidationErrorLocInner0 = string

// ValidationErrorLocInner1 defines model for .
type ValidationErrorLocInner1 = int

// ListClustersParams defines parameters for ListClusters.
type ListClustersParams struct {
	PrivateRegionId *string `form:"private_region_id,omitempty" json:"private_region_id,omitempty"`
}

// CreateClusterParams defines parameters for CreateCluster.
type CreateClusterParams struct {
	ClusterId *openapi_types.UUID `form:"cluster_id,omitempty" json:"cluster_id,omitempty"`
}

// DeleteClusterParams defines parameters for DeleteCluster.
type DeleteClusterParams struct {
	DeleteBackups *bool `form:"delete_backups,omitempty" json:"delete_backups,omitempty"`
}

// GetPackagesParams defines parameters for GetPackages.
type GetPackagesParams struct {
	Provider GetPackagesParamsProvider `form:"provider" json:"provider"`
	Region   GetPackagesParamsRegion   `form:"region" json:"region"`
}

// GetPackagesParamsProvider defines parameters for GetPackages.
type GetPackagesParamsProvider string

// GetPackagesParamsRegion defines parameters for GetPackages.
type GetPackagesParamsRegion string

// CreateApiKeyJSONRequestBody defines body for CreateApiKey for application/json ContentType.
type CreateApiKeyJSONRequestBody = ApiKeySchema

// UpdateApiKeyJSONRequestBody defines body for UpdateApiKey for application/json ContentType.
type UpdateApiKeyJSONRequestBody = ApiKeySchema

// CreateClusterJSONRequestBody defines body for CreateCluster for application/json ContentType.
type CreateClusterJSONRequestBody = ClusterSchema

// UpdateClusterJSONRequestBody defines body for UpdateCluster for application/json ContentType.
type UpdateClusterJSONRequestBody = ClusterSchema

// AsValidationErrorLocInner0 returns the union data inside the ValidationErrorLocInner as a ValidationErrorLocInner0
func (t ValidationErrorLocInner) AsValidationErrorLocInner0() (ValidationErrorLocInner0, error) {
	var body ValidationErrorLocInner0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLocInner0 overwrites any union data inside the ValidationErrorLocInner as the provided ValidationErrorLocInner0
func (t *ValidationErrorLocInner) FromValidationErrorLocInner0(v ValidationErrorLocInner0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLocInner0 performs a merge with any union data inside the ValidationErrorLocInner, using the provided ValidationErrorLocInner0
func (t *ValidationErrorLocInner) MergeValidationErrorLocInner0(v ValidationErrorLocInner0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsValidationErrorLocInner1 returns the union data inside the ValidationErrorLocInner as a ValidationErrorLocInner1
func (t ValidationErrorLocInner) AsValidationErrorLocInner1() (ValidationErrorLocInner1, error) {
	var body ValidationErrorLocInner1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromValidationErrorLocInner1 overwrites any union data inside the ValidationErrorLocInner as the provided ValidationErrorLocInner1
func (t *ValidationErrorLocInner) FromValidationErrorLocInner1(v ValidationErrorLocInner1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeValidationErrorLocInner1 performs a merge with any union data inside the ValidationErrorLocInner, using the provided ValidationErrorLocInner1
func (t *ValidationErrorLocInner) MergeValidationErrorLocInner1(v ValidationErrorLocInner1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ValidationErrorLocInner) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ValidationErrorLocInner) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListApiKeys request
	ListApiKeys(ctx context.Context, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateApiKeyWithBody request with any body
	CreateApiKeyWithBody(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApiKey(ctx context.Context, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiKey request
	DeleteApiKey(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateApiKeyWithBody request with any body
	UpdateApiKeyWithBody(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateApiKey(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, body UpdateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListClusters request
	ListClusters(ctx context.Context, accountId openapi_types.UUID, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClusterWithBody request with any body
	CreateClusterWithBody(ctx context.Context, accountId openapi_types.UUID, params *CreateClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCluster(ctx context.Context, accountId openapi_types.UUID, params *CreateClusterParams, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCluster request
	DeleteCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCluster request
	GetCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateClusterWithBody request with any body
	UpdateClusterWithBody(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackages request
	GetPackages(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListApiKeys(ctx context.Context, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListApiKeysRequest(c.Server, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKeyWithBody(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequestWithBody(c.Server, accountId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApiKey(ctx context.Context, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateApiKeyRequest(c.Server, accountId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiKey(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiKeyRequest(c.Server, accountId, apiKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApiKeyWithBody(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApiKeyRequestWithBody(c.Server, accountId, apiKeyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateApiKey(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, body UpdateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateApiKeyRequest(c.Server, accountId, apiKeyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListClusters(ctx context.Context, accountId openapi_types.UUID, params *ListClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClustersRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClusterWithBody(ctx context.Context, accountId openapi_types.UUID, params *CreateClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequestWithBody(c.Server, accountId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCluster(ctx context.Context, accountId openapi_types.UUID, params *CreateClusterParams, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClusterRequest(c.Server, accountId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteClusterRequest(c.Server, accountId, clusterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClusterRequest(c.Server, accountId, clusterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateClusterWithBody(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequestWithBody(c.Server, accountId, clusterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCluster(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateClusterRequest(c.Server, accountId, clusterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackages(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListApiKeysRequest generates requests for ListApiKeys
func NewListApiKeysRequest(server string, accountId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/accounts/%s/auth/api-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateApiKeyRequest calls the generic CreateApiKey builder with application/json body
func NewCreateApiKeyRequest(server string, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateApiKeyRequestWithBody(server, accountId, "application/json", bodyReader)
}

// NewCreateApiKeyRequestWithBody generates requests for CreateApiKey with any type of body
func NewCreateApiKeyRequestWithBody(server string, accountId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/accounts/%s/auth/api-keys", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteApiKeyRequest generates requests for DeleteApiKey
func NewDeleteApiKeyRequest(server string, accountId openapi_types.UUID, apiKeyId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "api_key_id", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/accounts/%s/auth/api-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateApiKeyRequest calls the generic UpdateApiKey builder with application/json body
func NewUpdateApiKeyRequest(server string, accountId openapi_types.UUID, apiKeyId string, body UpdateApiKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateApiKeyRequestWithBody(server, accountId, apiKeyId, "application/json", bodyReader)
}

// NewUpdateApiKeyRequestWithBody generates requests for UpdateApiKey with any type of body
func NewUpdateApiKeyRequestWithBody(server string, accountId openapi_types.UUID, apiKeyId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "api_key_id", runtime.ParamLocationPath, apiKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/accounts/%s/auth/api-keys/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListClustersRequest generates requests for ListClusters
func NewListClustersRequest(server string, accountId openapi_types.UUID, params *ListClustersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/accounts/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PrivateRegionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "private_region_id", runtime.ParamLocationQuery, *params.PrivateRegionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClusterRequest calls the generic CreateCluster builder with application/json body
func NewCreateClusterRequest(server string, accountId openapi_types.UUID, params *CreateClusterParams, body CreateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateClusterRequestWithBody(server, accountId, params, "application/json", bodyReader)
}

// NewCreateClusterRequestWithBody generates requests for CreateCluster with any type of body
func NewCreateClusterRequestWithBody(server string, accountId openapi_types.UUID, params *CreateClusterParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/accounts/%s/clusters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ClusterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cluster_id", runtime.ParamLocationQuery, *params.ClusterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteClusterRequest generates requests for DeleteCluster
func NewDeleteClusterRequest(server string, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/accounts/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.DeleteBackups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delete_backups", runtime.ParamLocationQuery, *params.DeleteBackups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClusterRequest generates requests for GetCluster
func NewGetClusterRequest(server string, accountId openapi_types.UUID, clusterId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/accounts/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateClusterRequest calls the generic UpdateCluster builder with application/json body
func NewUpdateClusterRequest(server string, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateClusterRequestWithBody(server, accountId, clusterId, "application/json", bodyReader)
}

// NewUpdateClusterRequestWithBody generates requests for UpdateCluster with any type of body
func NewUpdateClusterRequestWithBody(server string, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "cluster_id", runtime.ParamLocationPath, clusterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/accounts/%s/clusters/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPackagesRequest generates requests for GetPackages
func NewGetPackagesRequest(server string, params *GetPackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/public/v1/booking/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "provider", runtime.ParamLocationQuery, params.Provider); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "region", runtime.ParamLocationQuery, params.Region); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListApiKeysWithResponse request
	ListApiKeysWithResponse(ctx context.Context, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error)

	// CreateApiKeyWithBodyWithResponse request with any body
	CreateApiKeyWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	CreateApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error)

	// DeleteApiKeyWithResponse request
	DeleteApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyResponse, error)

	// UpdateApiKeyWithBodyWithResponse request with any body
	UpdateApiKeyWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApiKeyResponse, error)

	UpdateApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, body UpdateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApiKeyResponse, error)

	// ListClustersWithResponse request
	ListClustersWithResponse(ctx context.Context, accountId openapi_types.UUID, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error)

	// CreateClusterWithBodyWithResponse request with any body
	CreateClusterWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, params *CreateClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	CreateClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, params *CreateClusterParams, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error)

	// DeleteClusterWithResponse request
	DeleteClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error)

	// GetClusterWithResponse request
	GetClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetClusterResponse, error)

	// UpdateClusterWithBodyWithResponse request with any body
	UpdateClusterWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	UpdateClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error)

	// GetPackagesWithResponse request
	GetPackagesWithResponse(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*GetPackagesResponse, error)
}

type ListApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ApiKeySchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKeySchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateApiKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiKeySchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateApiKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateApiKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ClusterSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r ListClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r CreateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClusterSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r UpdateClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageSchema
	JSON422      *HTTPValidationError
}

// Status returns HTTPResponse.Status
func (r GetPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListApiKeysWithResponse request returning *ListApiKeysResponse
func (c *ClientWithResponses) ListApiKeysWithResponse(ctx context.Context, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*ListApiKeysResponse, error) {
	rsp, err := c.ListApiKeys(ctx, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListApiKeysResponse(rsp)
}

// CreateApiKeyWithBodyWithResponse request with arbitrary body returning *CreateApiKeyResponse
func (c *ClientWithResponses) CreateApiKeyWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKeyWithBody(ctx, accountId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

func (c *ClientWithResponses) CreateApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, body CreateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateApiKeyResponse, error) {
	rsp, err := c.CreateApiKey(ctx, accountId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateApiKeyResponse(rsp)
}

// DeleteApiKeyWithResponse request returning *DeleteApiKeyResponse
func (c *ClientWithResponses) DeleteApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, reqEditors ...RequestEditorFn) (*DeleteApiKeyResponse, error) {
	rsp, err := c.DeleteApiKey(ctx, accountId, apiKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiKeyResponse(rsp)
}

// UpdateApiKeyWithBodyWithResponse request with arbitrary body returning *UpdateApiKeyResponse
func (c *ClientWithResponses) UpdateApiKeyWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateApiKeyResponse, error) {
	rsp, err := c.UpdateApiKeyWithBody(ctx, accountId, apiKeyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApiKeyResponse(rsp)
}

func (c *ClientWithResponses) UpdateApiKeyWithResponse(ctx context.Context, accountId openapi_types.UUID, apiKeyId string, body UpdateApiKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateApiKeyResponse, error) {
	rsp, err := c.UpdateApiKey(ctx, accountId, apiKeyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateApiKeyResponse(rsp)
}

// ListClustersWithResponse request returning *ListClustersResponse
func (c *ClientWithResponses) ListClustersWithResponse(ctx context.Context, accountId openapi_types.UUID, params *ListClustersParams, reqEditors ...RequestEditorFn) (*ListClustersResponse, error) {
	rsp, err := c.ListClusters(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClustersResponse(rsp)
}

// CreateClusterWithBodyWithResponse request with arbitrary body returning *CreateClusterResponse
func (c *ClientWithResponses) CreateClusterWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, params *CreateClusterParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateClusterWithBody(ctx, accountId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

func (c *ClientWithResponses) CreateClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, params *CreateClusterParams, body CreateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateClusterResponse, error) {
	rsp, err := c.CreateCluster(ctx, accountId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateClusterResponse(rsp)
}

// DeleteClusterWithResponse request returning *DeleteClusterResponse
func (c *ClientWithResponses) DeleteClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, params *DeleteClusterParams, reqEditors ...RequestEditorFn) (*DeleteClusterResponse, error) {
	rsp, err := c.DeleteCluster(ctx, accountId, clusterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteClusterResponse(rsp)
}

// GetClusterWithResponse request returning *GetClusterResponse
func (c *ClientWithResponses) GetClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetClusterResponse, error) {
	rsp, err := c.GetCluster(ctx, accountId, clusterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClusterResponse(rsp)
}

// UpdateClusterWithBodyWithResponse request with arbitrary body returning *UpdateClusterResponse
func (c *ClientWithResponses) UpdateClusterWithBodyWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateClusterWithBody(ctx, accountId, clusterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

func (c *ClientWithResponses) UpdateClusterWithResponse(ctx context.Context, accountId openapi_types.UUID, clusterId openapi_types.UUID, body UpdateClusterJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateClusterResponse, error) {
	rsp, err := c.UpdateCluster(ctx, accountId, clusterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateClusterResponse(rsp)
}

// GetPackagesWithResponse request returning *GetPackagesResponse
func (c *ClientWithResponses) GetPackagesWithResponse(ctx context.Context, params *GetPackagesParams, reqEditors ...RequestEditorFn) (*GetPackagesResponse, error) {
	rsp, err := c.GetPackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagesResponse(rsp)
}

// ParseListApiKeysResponse parses an HTTP response from a ListApiKeysWithResponse call
func ParseListApiKeysResponse(rsp *http.Response) (*ListApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ApiKeySchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateApiKeyResponse parses an HTTP response from a CreateApiKeyWithResponse call
func ParseCreateApiKeyResponse(rsp *http.Response) (*CreateApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKeySchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteApiKeyResponse parses an HTTP response from a DeleteApiKeyWithResponse call
func ParseDeleteApiKeyResponse(rsp *http.Response) (*DeleteApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateApiKeyResponse parses an HTTP response from a UpdateApiKeyWithResponse call
func ParseUpdateApiKeyResponse(rsp *http.Response) (*UpdateApiKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateApiKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiKeySchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseListClustersResponse parses an HTTP response from a ListClustersWithResponse call
func ParseListClustersResponse(rsp *http.Response) (*ListClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ClusterSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseCreateClusterResponse parses an HTTP response from a CreateClusterWithResponse call
func ParseCreateClusterResponse(rsp *http.Response) (*CreateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteClusterResponse parses an HTTP response from a DeleteClusterWithResponse call
func ParseDeleteClusterResponse(rsp *http.Response) (*DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetClusterResponse parses an HTTP response from a GetClusterWithResponse call
func ParseGetClusterResponse(rsp *http.Response) (*GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseUpdateClusterResponse parses an HTTP response from a UpdateClusterWithResponse call
func ParseUpdateClusterResponse(rsp *http.Response) (*UpdateClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClusterSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetPackagesResponse parses an HTTP response from a GetPackagesWithResponse call
func ParseGetPackagesResponse(rsp *http.Response) (*GetPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageSchema
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest HTTPValidationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}
